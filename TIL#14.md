나의 공부방법이 잘못된것인지.. 쉬는날없이 주말에도 6시간 이상 코드를 보고있지만 마음처럼잘안되는거같다
점점 왜 코드가 이런식으로 돌아가는지 이해를 못하는거같다. 좌절감에 물들어가고있는것만 같다
하지만 어쩌겟는가 이좌절감도.. 극복할수밖에없다.. 오늘도 코드를 두눈으로 보고 생각하고 직접쓰면 좀나아지지 않겟나

### 자료구조

여러 데이터의 묶을을 저장하고 사용하는 방법을 정의

특정한 상황에 놓은 문제를 해결하는데에 특화

많은 자료구조를 알아두면 어떤상황이 닥쳤을때 적합한 자료구조를 바르고 정확하게 적용가능

### tree[구현]

트리구현을하는 부분이있었는데 늘 그렇듯이 머리속에 지도가 그려지지 않는다
트리에 삽입 메서드를 만드는데 바보같이 new 키워드를 자꾸사용하지않아서 테스트 케이스 통과가 되지않았다
사소한부분이지만 왜틀렷는지 잡나내지 못했었다 내가 부족햇다 다음에는 실수하지말자

```js
	// 트리의 삽입 메서드를 만듭니다.
  insertNode(value) {
		// 값이 어떤 이름으로 만들어지고 어느 위치에 붙는지 떠올리는 것이 중요합니다.
		// TODO: 트리에 붙게 될 childNode를 만들고, children에 넣어야 합니다.
    const childNode = fill_me_in;
    this.children.push(fill_me_in);
  }
```

두번째부분은 문제가 되지않았으니 넘어가고
// TODO: 값을 찾을 때까지 children 배열을 순회하며 childNode를 탐색하세요
이부분에서 상당히 시간이걸렷다 아무래도 재귀함수를 사용한다는것에 익숙하지않은것같다.. 어쩔수있나
그래도 약 70%정도 풀어내고 레포코드를 보고 풀엇다.... 보자마자 아! 뒤통수를 치는듯한 느낌이들며 단박에 이해를 했다
왜 나는 처음에 이런 코드들을 작성하지 못하는거지 ... 스읍;; 난이도가 계속올라가고있는데 코플릿문제나 토이 문제 레포를 안보고서는
풀기힘들다 더욱 연습해서 실력이늘길...

### 동기 && 비동기!

#### 동기(Synchronous)

1. Thread1이 작업을 시작 시키고, Task1이 끝날때까지 기다렸다 Task2를 시작한다.
2. 작업 요청을 했을 때 요청의 결과값(return)을 직접 받는 것이다.
3. 요청의 결과값이 return값과 동일하다.
4. 호출한 함수가 작업 완료를 신경 쓴다.

#### 비동기(Asynchronous)

1. Thread1이 작업을 시작 시키고, 완료를 기다리지 않고, Thread1은 다른 일을 처리할 수 있다.
2. 작업 요청을 했을 때 요청의 결과값(return)을 간접적으로 받는 것이다.
3. 요청의 결과값이 return값과 다를 수 있다.
4. 해당 요청 작업은 별도의 스레드에서 실행하게 된다.
5. 콜백을 통한 처리가 비동기 처리라고 할 수 있다.
6. 호출된 함수(callback 함수)가 작업 완료를 신경 쓴다.

### blocking vs non-blocking

blocking과 non-blocking은 주로 IO의 읽기, 쓰기에서 사용된다.

#### blocking

요청한 작업을 마칠 때까지 계속 대기한다.
즉시 return한다.
return 값을 받아야 끝난다.
Thread 관점으로 본다면, 요청한 작업을 마칠 때까지 계속 대기하며 return 값을 받을 때까지 한 Thread를 계속 사용/대기 한다.
non-blocking
요청한 작업을 즉시 마칠 수 없다면 즉시 return한다.
즉시 리턴하지 않는다. (일을 못하게 막는다.)
Thread 관점으로 본다면, 하나의 Thread가 여러 개의 IO를 처리 가능하다.
동기/비동기, blocking/non-blocking의 차이는?
사실 이렇게만 보면 동기랑 blocking이 비슷하고, 비동기랑 non-blocking이 비슷해보인다.
동기/비동기, blocking/non-blocking 두 그룹의 차이는 관심사가 다르다.

#### blocking/non-blocking

이 그룹은 호출되는 함수가 바로 return하느냐 마느냐가 관심사이다.

호출된 함수가 바로 return해서 호출한 함수에게 제어권을 넘겨주고
호출한 함수가 다른 일을 할 수 있는 기회를 줄 수 있으면 non-blocking이다.

호출된 함수가 자신의 작업을 모두 마칠 때까지
호출한 함수에게 제어권을 넘겨주지 않고 대기하게 만든다면 blocking이다.
